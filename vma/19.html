<!DOCTYPE html>
<html lang="cs">
	<head>
		<meta charset="UTF-8" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>19. Základy objektového programování v C++</title>

		<link rel="stylesheet" href="../main.css" />
		<script src="../main.js" defer></script>
	</head>
	<body>
		<div id="theme-switcher"></div>
		<a id="scroll-up" href="#" class="hidden">
			<svg
				xmlns="http://www.w3.org/2000/svg"
				width="24"
				height="24"
				viewBox="0 0 24 24"
				fill="none"
				stroke="currentColor"
				stroke-width="2"
				stroke-linecap="round"
				stroke-linejoin="round"
				class="feather feather-arrow-up"
			>
				<line x1="12" y1="19" x2="12" y2="5"></line>
				<polyline points="5 12 12 5 19 12"></polyline>
			</svg>
		</a>

		<nav>
			<a href="../">Rozcestník</a>
			<a href="#deklarace">Deklarace</a>
			<a href="#definice-metod">Definice metod</a>
			<a href="#const">Const</a>
			<a href="#this">This</a>
		</nav>

		<main>
			<h1>19. ZÁKLADY OBJEKTOVÉHO PROGRAMOVÁNÍ V C++</h1>
			<h2>Vznik objektově orientovaného programování</h2>
			<p>
				První počítače dostávaly příkazy ve formě strojového kódu, což
				pro lidi, kteří se o IT nezajímali bylo naprosto
				nepředstavitelné, ale software ani hardware nebyl na takové
				úrovni, aby příkazy pro procesor dosáhly nějaké větší
				složitosti.
			</p>
			<p>
				S vývojem počítačů se kladly větší nároky i na programy a
				vyvinulo se nestrukturované paradigma, tedy jakýsi soubor
				příkazů, který procesor vykonával, a vzniklo tak strukturované
				programování, tedy seznam přikazů, které procesor vykonává podle
				jejich pořadí od shora dolů.
			</p>
			<p>
				Ke vzniku objektově orientovaného programování napomohl neustálý
				vývoj počítačových systémů a samotných počítačů. S přibývajícími
				nároky na programátory v komplexnosti programů se strukturovaně
				programovaný kód stávál nepřehledným, při větších objemech kódu
				i neudržovatlný a proto se musel vytvořit nový přístup k
				programování. Objektově orientovaný přístup k programování.
			</p>
			<h2>Podstata objektově orientovaného programování</h2>
			<p>
				Objektově orientované programování se zakládá na několika
				základních pilířích a dává se v něm důraz na znovupoužitelnost
				kódu a dává programátorovi jistou vrstvu abstrakce nad
				programem.
			</p>

			<table>
				<tr>
					<th class="center">Point</th>
				</tr>
				<tr>
					<td class="code">
						-x:int = 0 <br />
						-y:int = 0
					</td>
				</tr>
				<tr>
					<td class="code">
						+Point(x:int, y:int) <br />
						+getX():int <br />
						+setX(x:int):void <br />
						+getY():int <br />
						+setY(y:int):void <br />
						+setXY(x:int, y:int):void <br />
						+print():void <br />
					</td>
				</tr>
			</table>

			<p>
				V tomto přístupu k programování se programátor snaží popsat svět
				jak ho vidí on a ne jak ho vidí počítač a píše program z pohledu
				člověka a to mu dává tu jistou abstrakci.
			</p>

			<p>
				Základní jednotka objektového programování je <b>objekt</b>​.
				Jedná se o entitu, která odpovídá objektům z reálného světa.
				Například Pes, pes má 4 nohy, hlavu, oči a může mít i jméno,
				ještě k tomu štěká. Objekt by se v programovaní popsal Atributy
				(vlastnostmi objektu) a Metodami(schopnostmi objektu).
			</p>

			<img
				src="img/19-objekt.jpg"
				alt="Objekt"
				loading="lazy"
				class="invertable"
			/>

			<p>
				Z těchto objektů programátor postupně vytváří hierarchii
				objektů, které mezi sebou mohou komunikovat a v hierarchii na
				sobě být nějakým způsobem závislé. O tuto hierarchii se starají
				tři zmíněné pilíře a to jsou:
			</p>

			<h3>1. Zapouzdření</h3>
			<p>
				Jedná se o uschování atributů nebo metod objektu od okolních
				objektů pomocí přístupových modifikátorů, může sloužit pro účel
				nadřazenosti v hierarchii, ale je také důležité při zabezpečení
				programu a kontrolujeme tak, k čemu má program vlastně sám bez
				zásahu programátora přístup a také chrání program před špatným
				použití takto schovaných metod nebo proměnných.
			</p>

			<h4>Přístupové modifikátory</h4>
			<ul>
				<li>
					1. public
					<ul>
						<li>přístupné odkudkoliv</li>
					</ul>
				</li>
				<li>
					2. private
					<ul>
						<li>
							proměnná nebo metoda není přístupná nikde jinde než
							ve třídě, ve které byla definována
						</li>
						<li>
							pokud ve
							<b
								>třídě(v jiných datových strukturách může
								fungovat jinak)</b
							>
							nespecifikujeme přístupový modifikátor, program
							proměnnou nebo metodu sám definuje na private
						</li>
						<li>
							pokud chceme k private proměnné přistoupit z jiné
							třídy musíme vytvořit public metodu, ve třídě kde je
							proměnná definována, která s ní může manipulovat
						</li>
					</ul>
				</li>
				<li>
					3. protected
					<ul>
						<li>
							v c++ nejsou žádné balíčky, takže neplést s javou (:
						</li>
						<li>
							proměnné a metody s modifikátorem protected jsou
							přístupné pro třídu, ve které jsou definovány a ve
							třídě, která dědí od třídy ve které jsou definovány.
						</li>
					</ul>
				</li>
			</ul>

			<h3>2. Dědičnost</h3>
			<p>
				Tvoří vlastně celou hierarchii objektů a stará se tak o celou
				vrstvu abstrakce nad programem. Jedná se o dědění atributů a
				metod z rodičovské třídy a třída, která dědí se tak stává dědící
				třídou. Využívá se u objektů, které sdílí více stejných atributů
				nebo metod a podporuje se tak znovu použitelnost kódu.
			</p>

			<h3>3. Polymorfismus</h3>
			<p>
				Nám umožňuje používat stejné atributy a metody pro různé druhy
				objektů. Například u geometrických tvarů si můžeme vytvořit
				rodičovskou třídu geometrickyObjekt a dvě dědící třídy čtverec a
				obdélník, pokud bychom chtěli vypočítat obsah obou dědících tříd
				museli bychom udělat dvě různojmené metody. Polymorfismus
				zajisti to, že můžeme udělat jen jednu metodu v rodičovské třídě
				a každá dědící třída už si přepíše svou implementaci teto
				metody, tedy vzorec na výpočet obsahu čtverce a obdélníku.
			</p>

			<h2>Třída vs Instance třídy</h2>
			<p>
				<b>Třída</b> ​je vzor, podle kterého se objekt následně vytváří.
				Definuji se v ni vsechny atributy a metody.
			</p>

			<p>
				<b>Instance</b> třídy je objekt vytvořen podle třídy. Instance
				třídy mají tedy strukturu třídy, podle které byly vytvořeny, ale
				liší se svými daty, jako například jménem.
			</p>

			<h2 id="deklarace">Deklarace třídy</h2>
			<p>
				Jak je zmíněno výš, třída je vlastně jen vzor, podle kterého se
				poté vytvářejí samotné objekty. Samotná třída v sobě tedy
				neuchovává data, ale pouze specifikuje jaké data v sobě objekt
				bude uchovávat a jaké činnosti bude moct objekt dělat.
			</p>
			<p>
				Definice třídy začíná klíčovým slovem <b>class</b>​, jménem
				třídy a tělem třídy, které je uzavřené složenými závorkami. Celá
				deklarace třídy musí být ukončena středníkem, nebo seznamem
				objektů, které ze třídy chceme vytvořit.
			</p>

			<p>
				<code>
					<span class="p">class</span> <span class="y">Box</span> {
					<br />

					&#160; &#160; <span class="p">public:</span> <br />
					&#160; &#160; &#160; &#160;
					<span class="p">double</span> length;
					<span class="comment">// délka boxu</span> <br />

					&#160; &#160; &#160; &#160;
					<span class="p">double</span> breadth;
					<span class="comment">// šířka boxu</span> <br />

					&#160; &#160; &#160; &#160;
					<span class="p">double</span> height;
					<span class="comment">// výška boxu</span> <br />

					};
				</code>
			</p>

			<h2>Definice objektu</h2>
			<p>
				Je ve zkratce operace, kdy se vytváří samotný objekt, podle
				předložené třídy. Takže se definice objektu skládá ze jména
				třídy, podle které se náš objekt vytvoří a jménem námi
				vytvořeného objektu.
			</p>
			<p>
				<code>
					<span class="p">Box</span> box1; <br />
					<span class="p">Box</span> box2; <br />
				</code>
			</p>

			<h2>Přístup ke členům objektu</h2>
			<p>
				K členským proměnným a metodám se přistupuje v c++ pomocí tečky
				(.​). Celý přístup k proměnné nebo metodě vypadá tak, že
				označíme, do kterého objektu chceme přistoupit a pak jen zvolíme
				proměnnou, ke které chceme přistoupit a která se nachází v námi
				zvoleném objektu. Takto přímo lze přistoupit pouze k proměnným s
				modifikátorem <b>public</b>​. Pokud se jedná o
				<b>private</b> nebo <b>protected</b> a chceme k nim přistoupit,
				tak musíme vytvořit <b>public</b> metody, které s nimi budou
				moct manipulovat. Nazývají se <b>getry</b> a <b>setry</b>.
				<b>Getry</b> na získání hodnoty proměnné a <b>Setry</b>​ na
				nastavení hodnoty proměnné
			</p>

			<p>
				<code>
					<span class="p">Box</span> box1; <br />
					<span class="p">Box</span> box2; <br />
					<span class="p">double</span> volume =
					<span class="y">0.0</span>;
					<span class="comment">// proměnná objem</span> <br />
					<br />

					<span class="comment">// vlastnosti boxu 1</span> <br />
					<span class="p">box1</span>.height =
					<span class="y">5.0</span>;<br />

					<span class="p">box1</span>.height =
					<span class="y">6.0</span>;<br />

					<span class="p">box1</span>.height =
					<span class="y">7.0</span>;<br />

					<br />

					<span class="comment">// vlastnosti boxu 2</span> <br />
					<span class="p">box2</span>.height =
					<span class="y">10.0</span>;<br />

					<span class="p">box2</span>.height =
					<span class="y">12.0</span>;<br />

					<span class="p">box2</span>.height =
					<span class="y">13.0</span>;<br />
				</code>
			</p>

			<h2 id="definice-metod">Definice metod</h2>
			<p>
				Metoda třídy je definována v jejím těle pomocí jejího
				návratového typu, jejího jména, parametrů,které metoda přijímá v
				kulatých závorkách a jejím tělem, uzavřeným ve složených
				závorkách.
			</p>

			<p>
				<code>
					<span class="p">double</span>
					<span class="b">getVolume</span>(<span class="p">void</span
					>) { <br />

					&#160; &#160; <span class="p">return</span> length * breadth
					* height; <br />

					}
				</code>
			</p>

			<p>
				Metodu můžeme definovat v těle třídy a nebo mimo tělo třídy
				pomocí operátoru (::) (<b>scope resolution operator</b>​) .
				Pokud však nedefinujeme metodu v těle třídy, musíme v něm udělat
				předlohu metody.
			</p>

			<p>
				<code>
					<span class="p">double</span>
					<span class="y">Box</span>::<span class="b">getVolume</span
					>(<span class="p">void</span>) { <br />

					&#160; &#160; <span class="p">return</span> length * breadth
					* height; <br />

					}
				</code>
			</p>

			<p>
				Metody v objektu mají přístup ke všem proměnným a to i k
				proměnným s jinými modifikátory než <b>public</b>​, což se hodí
				při manipulaci s <b>private</b> nebo
				<b>protected</b> proměnnýma.
			</p>

			<h2 id="const">Const metoda</h2>

			<p>
				Metoda označená klíčovým slovem <b>const</b> může pouze číst
				členské proměnné a nemůže je nijak upravit. Používá se k ochraně
				před nechtěným změněním proměnných v objektu.
			</p>

			<p>
				<code>
					<span class="p">int</span> <span class="b">getArea</span>()
					<span class="p">const</span> {
					<br />
					&#160; &#160; <span class="p">return</span> m_len * m_width;
					<br />

					}
				</code>
			</p>

			<h2 id="this">Ukazatel this</h2>
			<p>
				Každý objekt má v c++ k dispozici přístup ke své adrese pomocí
				ukazatele <b>this​</b>. Ukazatel this je bezpodmínečně přístupný
				všem členským metodám a tak v nich tedy takto můžeme ukázat na
				objekt, který danou metodu volá.
			</p>

			<p>
				<code>
					<span class="p">int</span>
					<span class="b">compare</span>(<span class="y">Box</span>
					<span class="r">box</span>) { <br />
					&#160; &#160; <span class="p">return</span>
					<span class="y">this</span>-><span class="b">Volume</span>()
					> <span class="y">box</span>.<span class="b">Volume</span
					>(); <br />
					}
				</code>
			</p>

			<h2>Konstruktor</h2>
			<p>
				<b>Kostruktor</b> je speciální metoda, která nese stejné jméno
				jako třída, ve které se nachází a spouští se pokaždé, když je ze
				třídy vytvořen objekt. Základní konstruktor nemá parametry, ale
				pokud potřebujeme můžeme mu je přidat a použít tak kostruktor
				pro dosazení počátečních hodnot do objektu
			</p>

			<h2>Destruktor</h2>
			<p>
				<b>Destruktor</b> je stejný jako konstruktor jen s drobnými
				rozdíly. Prvním z nich je, že před destruktor se píše
				<b>~ (tilda)</b> a druhým je to, že se destruktor volá při
				ničení objektu, tedy stavu, kdy na objekt nic neukazuje a
				garbage collector ho smaže nebo při manuálním smazání.
			</p>

			<p>
				<code>
					<span class="p">class</span> <span class="y">Line</span> {
					<br />

					&#160; &#160; <span class="p">public:</span> <br />
					&#160; &#160; &#160; &#160;
					<span class="p">void</span>
					<span class="b">setLength</span>(<span class="p"
						>double</span
					>
					len); <br />
					&#160; &#160; &#160; &#160;
					<span class="p">double</span>
					<span class="b">getLength</span>(<span class="p">void</span
					>); <br />
					&#160; &#160; &#160; &#160; <span class="b">Line</span>();
					<span class="comment">// deklarace konstruktoru</span>
					<br />
					&#160; &#160; &#160; &#160; ~<span class="b">Line</span>();
					<span class="comment">// deklarace destruktoru</span>
					<br />
					&#160; &#160; <span class="p">private:</span> <br />
					&#160; &#160; &#160; &#160;
					<span class="p">double</span> length; <br />

					};
				</code>
			</p>

			<h2>Statické a dynamické instance třídy</h2>
			<h3>Staticky definovaná instance třídy</h3>
			<p>
				Staticky definovaná instance třídy se zničí na konci bloku kódu,
				ve kterém je definována zatím co o zničení
				<b>dynamicky definované instanci třídy</b> rozhoduje programátor
				pomocí příkazu <b>delete[]</b>​. Rozdílný je taky přístup ke
				členům instancí. Při statické definici se používá
				<b>tečka(.)​</b>, zatím co u dynamické definice se používá
				<b>šipka(→)</b>.
			</p>

			<p>
				<code>
					<span class="p">Time</span> t(<span class="y">12</span>,
					<span class="y">0</span>, <span class="y">0</span>); <br />

					t.<span class="b">GetTime</span>(); <br />
				</code>
			</p>

			<h3>Dynamicky definovaná instance třídy</h3>
			<p>
				Dynamicky definovaná třída ​je v podstatě ukazatel na objekt,
				proto také ten jiný přístup ke členům
			</p>
			<p>
				<code>
					<span class="p">Time</span>* t = <span class="p">new</span>
					<span class="b">Time</span>(<span class="y">12</span>,
					<span class="y">0</span>, <span class="y">0</span>); <br />

					t-><span class="b">GetTime</span>();
				</code>
			</p>
		</main>

		<script src="../smooth-scroll.min.js"></script>
		<script>
			var scroll = new SmoothScroll('a[href*="#"]');
		</script>
	</body>
</html>
