<!DOCTYPE html>
<html lang="cs">
	<head>
		<meta charset="UTF-8" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>23. SOFTWAROVÉ INŽENÝRSTVÍ</title>

		<link rel="stylesheet" href="../main.css" />
		<script src="../main.js" defer></script>
	</head>
	<body>
		<div id="theme-switcher"></div>
		<a id="scroll-up" href="#" class="hidden">
			<svg
				xmlns="http://www.w3.org/2000/svg"
				width="24"
				height="24"
				viewBox="0 0 24 24"
				fill="none"
				stroke="currentColor"
				stroke-width="2"
				stroke-linecap="round"
				stroke-linejoin="round"
				class="feather feather-arrow-up"
			>
				<line x1="12" y1="19" x2="12" y2="5"></line>
				<polyline points="5 12 12 5 19 12"></polyline>
			</svg>
		</a>

		<nav>
			<a href="../">Rozcestník</a>
			<a href="#pozadavky-na-software">Požadavky na software</a>
			<a href="#realizace-uc">Realizace UC</a>
			<a href="#verifikace-a-validace">Verifikace a validace</a>
			<a href="#odhady-pracnosti-a-doby-reseni"
				>Odhady pracnosti a doby řešení</a
			>
		</nav>

		<main>
			<h1>23. SOFTWAROVÉ INŽENÝRSTVÍ</h1>
			<h2>Historie a definice Softwarového Inženýrství</h2>
			<p>
				V 60.letech nastala <b>softwarová krize</b>​, kdy se přemnožily
				projekty, které nemohly být včas vyřešeny. Software byl
				<b>nespolehlivý</b> a v mnohých
				<b>případech docházelo k havariím</b>​. Proto potřebovala být
				vynalezena disciplína, která by uvedla standard pro vývoj
				software a jeho dokumentaci, jak pro uživatele, tak pro vývojový
				tým.
			</p>
			<p>
				Softwarové inženýrství je <b>disciplína</b>,​ která se zabývá
				zavedením a používáním řádných inženýrských postupů při vývoji
				software a cílem je vyvinout
				<b>ekonomický a spolehlivý software</b> pro dostupný hardware.
			</p>
			<h2>Softwarový produkt</h2>
			<p>
				Je počítačový program, který v sobě zahrnuje dokumentaci jak
				uživatelskou i vývojovou. Softwarový produkt se dá rozdělit na
				<b>generický</b>​, tedy vyvíjený pro trh, a nebo
				<b>zakázkový</b>​, který je vyvíjený na požadavky zákazníka.
			</p>
			<h2>Etapy vývoje software</h2>
			<ol>
				<li><b>Koncepce​ -</b> úvodní studie</li>
				<li><b>Analýza​ -</b> požadavky a návrh</li>
				<li><b>Implementace​ -</b> kódování</li>
				<li><b>Testování</b></li>
				<li><b>Používání a údržba</b></li>
			</ol>
			<h2>Úvodní studie</h2>
			<p>
				Měla by stanovit základní <b>popis</b> softwaru, jeho
				<b>účel</b>​, <b>rozsah</b>​, cílové <b>uživatele</b> a podmínky
				pro <b>omezení</b> vývoje. Studie by měla také shrnout základní
				<b>cíl</b> ​projektu, v hrubém provedení stanovit
				<b>požadavky</b> pro daný systém, shrnout obecné <b>funkce</b> a
				naznačit <b>předpokládaný</b> <b> časový harmonogram​. </b>
			</p>
			<h2>Etický kodex softwarového inženýra</h2>
			<ol>
				<li>Software nesmí být v rozporu s veřejným zájemcem</li>
				<li>
					Jednat vždy v nejlepším zájmu klienta a zaměstnavatele,
					pokud není v rozporu s předchozím bodem
				</li>
				<li>
					Mít jistotu, že produkt a jeho změny jsou na nejvyšší možné
					úrovni
				</li>
				<li>Zachovat nezávislý profesionální úsudek</li>
				<li>
					Manažeři v oblasti SWI mají propagovat etický kodex při
					vývoji
				</li>
				<li>
					Dbát na reputaci oboru v souladu s veřejným zájmem, ale ne v
					rozporu s ním
				</li>
			</ol>
			<h2>Softwarový proces</h2>
			<p>
				Definuje kdo, co, kdy vykonává a rozlišuje přitom zákazníka,
				dodavatele a uživatele. Rozděluje se na:
			</p>
			<ol>
				<li class="b">
					Analýzu a specifikace
					<ul class="n">
						<li>Analyzuje rizika a sbírá požadavky</li>
						<li>Příprava akceptačního testu</li>
					</ul>
				</li>
				<li class="b">
					Architektonický návrh
					<ul class="n">
						<li>Koncept systému</li>
						<li>Rozklad systému na menší části</li>
						<li>Postup nasazení a plán testování</li>
					</ul>
				</li>
				<li class="b">
					Implementaci a testování
					<ul class="n">
						<li>Kódování, tedy tvorba samotného softwaru v kódu</li>
						<li>Testování jednotlivých částí systému</li>
					</ul>
				</li>
				<li class="b">
					Integraci a testování
					<ul class="n">
						<li>
							Spojení částí systému v jeden celek a jeho následné
							testování
						</li>
					</ul>
				</li>
				<li class="b">
					Akceptační testování a instalaci
					<ul class="n">
						<li>
							Ověření zákazníka, že systém funguje podle
							předpokladů
						</li>
					</ul>
				</li>
				<li class="b">
					Provoz a údržbu
					<ul class="n">
						<li>Oprava chyb, které vzniknou po nasazení</li>
						<li>Rozvoj podle měnících se požadavků</li>
					</ul>
				</li>
			</ol>
			<h3>Vodopádový model</h3>
			<p>
				Dělí projekt do nepružných fází a <b>neumožňuje</b> tak reagovat
				na měnící se požadavky. Proto je vhodný pro projekty, při
				kterých jsou pevně definovány požadavky (v praxi
				<b> velmi malé procento​ projektů </b>). Využívá se především
				při vývoji podsystémů u velkých projektů.
			</p>
			<img
				src="img/23-vodopadovy-model.jpg"
				alt="Vodopádový model"
				class="invertable"
			/>
			<h3>Přírůstkový model</h3>
			<p>
				Software není dodán jako celek, ale je dodáván
				<b>po částech​</b>. Umožňuje reagovat na požadavky dodávané před
				každou částí a zůstávají <b>fixní</b> po celou dobu vývoje dané
				části. Zákazník tak může hodnotit funkcionalitu systému po každé
				dodané části a dostává funkční systém o něco dříve.
			</p>
			<h3>Spirálový model</h3>
			<p>
				Je reprezentovaný <b>spirálou</b>​, jedno otočení spirály
				představuje jednu vývojovou fázi projektu. Spirála nemá dané
				specifické rozdělení fází, lze modifikovat dle potřeby. Výhody
				spočívají v možnosti reagovat na měnící se požadavky, při každém
				otočení spirály (<b>
					jedna fáze nastává víc než jednou za dobu vývoje​ </b
				>) a v tom, že po každé otočce přináší tento model
				<b>prototyp</b> softwaru.
			</p>
			<img
				src="img/23-spiralovy-model.jpg"
				alt="Spirálový model"
				class="invertable"
			/>
			<h2>Bussiness procesy</h2>
			<p>
				Popisují fungování firmy a postup jak řeší situace a úkoly.
				Určují interní a externí procesy nebo vazby. Popisují se
				nejčastěji pomocí BPMN (<b>Bussiness Process Model Notation​</b
				>), méně častěji pomocí diagramů UML.
			</p>
			<img
				src="img/23-business-procesy.jpg"
				alt="Bussiness procesy"
				class="invertable"
			/>
			<h2 id="pozadavky-na-software">Požadavky na software</h2>
			<p>
				Určují funkcionalitu vytvářeného systému, která je
				vykomunikována se zákazníky a uživateli ještě před zahájením
				vývoje. Požadavky jsou následně analyzovány a doplněny o
				potřebné funkce nebo jsou odstraněny nesrovnalosti a nejasnosti,
				které by v průběhu vývoje mohly dobu vývoje prodloužit.
			</p>
			<p>
				Požadavky se dají sbírat spoustu způsoby, například pomocí
				pozorování, přes dotazníky nebo při přímém pohovoru se
				zadavatelem. Při analýze by získané požadavky měly určit
				priority při vývoji daného systému.
			</p>
			<h3>Funkční požadavky</h3>
			<p>
				<b>Funkce a služby systému</b>​. Může se jednat například o
				<b>výběr zboží</b> nebo <b> přidaní zboží do košíku​ </b> u
				e-shopů.
			</p>
			<h3>Nefunkční požadavky</h3>
			<p>
				Nesouvisí s funkcemi z pohledu uživatele. Patří sem
				<b> spolehlivost a robustnost </b> systému, výběr
				<b>programovacího jazyka</b>​ nebo <b> typ aplikace </b>​
				(webová vs desktop vs mobilní)
			</p>
			<h3>Doménové požadavky</h3>
			<p>
				“Vycházejí z aplikační domény”. Mohou být funkční nebo
				mimofunkční. Příkladem je například čas potřebný k doručení
				zásilky, nebo zpoždění při její dopravě.
			</p>
			<h2>Jazyk UML</h2>
			<p>
				Jazyk UML pochází z anglické zkratky Unified Modeling Language.
				Byl vytvořen společností OMG (Object Management Group), první
				návrh UML 1.0 byl představen v lednu 1997. Jedná se o obrázkový
				jazyk a slouží k vytváření softwarových plánů. Slouží k
				vizualizaci, specifikování, sestrojení a dokumentování SW
				systému, není však omezen pouze na SW produkty (viz výrobní
				linky, management apod.).
			</p>
			<p>
				Nejedná o programovací jazyk v pravém slova smyslu, mohou být
				však využity nástroje, které na základě UML dokáží generovat
				programový kód. UML je úzce spjat s objektově orientovanou
				analýzou a návrhem.
			</p>
			<p>
				UML modeluje systém jako kolekci objektů, které spolupracují na
				realizaci potřeb uživatele.
			</p>
			<ul>
				<li>Statická struktura – jaké objekty jsou důležité</li>
				<li>
					Dynamické chování – životní cyklus objektů, jejich interakce
					k dosažení cílů
				</li>
			</ul>
			<p>
				UML lze rozdělit na tzv. stavení bloky, činnosti a architekturu
			</p>
			<ul>
				<li>Prvky – elementy diagramů</li>
				<li>Vazby – spojnice mezi elementy</li>
				<li>Diagramy – skupiny prvků a vazeb, pohledy na model</li>
			</ul>
			<h2>Objekty a objektový přístup</h2>
			<p>
				V tomto přístupu k programování se programátor snaží popsat svět
				jak ho vidí on a ne jak ho vidí počítač a píše program z pohledu
				člověka a to mu dává tu jistou abstrakci.Základní jednotka
				objektového programování je objekt. Jedná se o entitu, která
				odpovídá objektům z reálného světa. Například Pes, pes má 4
				nohy, hlavu, oči a může mít i jméno, ještě k tomu štěká.Objekt
				by se v programovaní popsal Atributy (vlastnostmi objektu) a
				Metodami (schopnostmi objektu). Z těchto objektů programátor
				postupně vytváří hierarchii objektů, které mezi sebou mohou
				komunikovat a v hierarchii na sobě být nějakým způsobem závislé.
			</p>
			<img src="img/23-objekty.jpg" alt="Objekty" class="invertable" />
			<h2 id="realizace-uc">Realizace UC</h2>
			<p>
				Use Case (UC) je typicky seznam akcí nebo událostí, které
				definují interakci mezi uživatelem nebo externím systémem a
				systémem, pro který UC vytváříme. Zorganizují se tak funkční
				požadavky, a definují se výsledný produkt daných interakcí,
				včetně všech akcí potřebných k dosažení výsledku (scénáře, které
				mohou nastat)
			</p>
			<img
				src="img/23-realizace-uc.jpg"
				alt="Realizace UC"
				class="invertable"
			/>
			<h2>Návrh Uživatelského rozhraní</h2>
			¨
			<p>
				Návrh uživatelského rozhraní je významný pro uživatele.
				Interakční styly zahrnují přímou obsluhu, menu, vyplňování
				formulářů, příkazové řádky, přirozený jazyk. Grafické zobrazení
				lze využít pro zachycení trendů, přibližných hodnot, technologií
				apod. Barvy jsou přínosné, ale musí použity střídmě,
				konzistentně. Návrh UI zahrnuje analýzu, prototypování, ověření.
				Cílem analýzy je poznat jak uživatelé pracují, jaké jsou jejich
				představy. Prototypování zahrnujepapírové prototypy až po
				automatizované – interaktivní prototypy. Cílem ověření je
				zhodnotit shodnu s požadavky, ověřit zda uživatelé pracují jak
				mají apod.
			</p>
			<h2>Bezpečnostně kritické systémy</h2>
			<p>
				Kritický systém je takový systém jehož selhání může vést k
				ekonomickým ztrátám, poškození zařízení nebo zdraví. Provozní
				spolehlivost odráží také důvěru uživatelů. Dostupnost systému
				určuje pravděpodobnost funkčnosti v určitém časovém úseku.
				Spolehlivost určuje pravděpodobnost správné činnosti určité
				funkce systému. Spolehlivost i dostupnost jsou nezbytné, ale ne
				postačující podmínky bezpečnosti a zabezpečení systému.
				Spolehlivost jako parametr určuje pravděpodobnost výskytu chyby,
				známé chyby neovlivní spolehlivost. Bezpečnost je soubor
				vlastností systému, které musí být dosaženy, aby nedošlo k
				poškození prostředí nebo zdraví. • Zabezpečení určuje schopnost
				systému odolat vnějšímu útoku. Zlepšení provozní spolehlivosti
				vyžaduje sociotechnický přístup k návrhu systému.
			</p>
			<h2>Softwarové modely</h2>
			<p>
				Model je abstraktní pohled na systém. Dílčí typy modelů
				poskytují různý pohled na systém. Kontextové modely zasazují
				systém do okolí. Modely datových toků zachycují zpracování dat v
				systému. Stavové automaty definují chování Sémantické modely
				určují strukturu dat vstupujících a vystupujících ze systému.
				Objektový model popisuje logické entity systému, jejich vazby a
				agregaci. Sekvenční modely zachycují interakci mezi aktory a
				objekty, které realizují jejich činnost. Strukturní metody
				poskytují rámec pro modelování systémů na vnější i vnitřní
				podněty.
			</p>
			<h2>Návrh a architektura software</h2>
			<p>
				Softwarová architektura je rámec pro strukturování software.
				Architektonický návrh aplikace určuje, strukturu aplikace, styl
				návrhu, apod. Vytváří se různé pohledy – modely –Model
				struktury, řízení, dekompozice. Mezi tzv. organizační modely
				sdílené úložiště dat, klient-serve, vrstvový model. Dekompozici
				systému na moduly, lze zachytit objektovým modelem nebo pomocí
				tzv. pileline modelu. Modely řízení zahrnují centrální řízení
				nebo řízení událostmi
			</p>
			<h2 id="verifikace-a-validace">Verifikace a validace</h2>
			<p>
				Cílem verifikace je ověřit, že je software vytvořený správně tj.
				že software odpovídá specifikaci. Oproti tomu cílem validace je
				ověřit, že je vytvořený správný software, tedy že software
				odpovídá tomu, co uživatelé skutečně požadují. Proces verifikace
				a validace je aplikován celou dobu trvání softwarového procesu.
				Má dva základní cíle:
			</p>
			<ul>
				<li>Objevení defektů v softwaru.</li>
				<li>
					Hodnocení, zda je software užitečný a použitelný v prostředí
					nasazení.
				</li>
			</ul>
			<p>Existují dva druhy verifikace: Statická a dynamická</p>
			<ul>
				<li>
					Statická verifikace - Kontrola software, zabývá se analýzou
					statické reprezentace softwaru a hledání problémů.
				</li>
				<li>
					Dynamická verifikace - Testování software, zabývá se
					chováním systému, kde jsou vlastnosti hodnoceni na základě
					testovacích dat.
				</li>
			</ul>
			<h2>Testování software</h2>
			<p>
				Testování může odhalit chyby, nemůže nám však zaručit, že žádná
				další chyba není. Vývojáři komponentů jsou zodpovědní za test
				svých komponentů. Testování systému se provádí nezávisle.
			</p>
			<p>
				Cílem je hledání chyb. Úspěšný test je takový, který způsobí
				neočekávané chování systému. Testy zjistí přítomnost chyby,
				nikoliv nepřítomnost.
			</p>
			<ul>
				<li>
					Validační testování: Cílem je ukázat všem zúčastněným, že
					systém splňuje požadavky. Úspěšný test je takový, který
					prokáže, že systém pracuje, jak se očekává.
				</li>
				<li>
					Chybové testování: Cílem je najít chyby v softwaru, tam kde
					jeho chování je v rozporu se specifikací. Úspěšný test již
					byl definován (takový, který prokáže špatné chování).
				</li>
			</ul>
			<p>
				Integrační testování spočívá v testování přírůstků. Testování
				sestavení se provádí před předáním uživateli. Je dobré využívat
				pravidla, zkušenosti při návrhu testů. Automatizace testů,
				přináší možnost opakování testů, využití sw. nástrojů. Závěr by
				měl být dle přístup KISS (Keep it simple and stupid). Návrh SW a
				programování by mělo být jednoduché.
			</p>
			<h2>Projektové řízení</h2>
			<p>
				Projekt je činnost v určitém časovém horizontu. Projektové týmy
				řeší otázku spolupráce. Projektové řízení řídí čas, zdroje a
				řeší kolize. Projektové řízení se stará o základní otázky jako
				co má být projektem dosaženo, jak dlouho bude projekt trvat,
				jaké činnosti projektu jsou kritické, co se stane při
				nedodržování termínů nebo jaké budou náklady na projekt.
			</p>
			<img
				src="img/23-projektove-rizeni.jpg"
				alt="Projektové řízení"
				class="invertable"
			/>
			<h2 id="odhady-pracnosti-a-doby-reseni">
				Odhady pracnosti a doby řešení
			</h2>
			<h3>Hostadlerův zákon</h3>
			<p>
				V softwaru vše stojí více a trvá déle, a to i tehdy, když
				provedeme na tuto skutečnost korekci původního odhadu. Odhady
				jsou optimistické. Lidé vždy předpokládají, že vše půjde
				"dobře". Obvykle vše trvá minimálně o 1/3 déle.
			</p>
			<h3>Metody odhadů</h3>
			<ul>
				<li>
					Expertní odhady
					<ul>
						<li>Odhad založen na zkušenosti experta</li>
						<li>
							Pracnost fází bývá obvykle:
							<ul>
								<li>16 % analýza</li>
								<li>17 % návrh</li>
								<li>34 % kódování a jednotkové testy</li>
								<li>18 % integrační testy</li>
								<li>8 % dokumentace</li>
								<li>7 % instalace a nasazení</li>
							</ul>
						</li>
					</ul>
				</li>
				<li>
					Analogie
					<ul>
						<li>
							Založeno na podobných projektech a identifikaci
							rozdílů mezi novým a již řešenými projekty
						</li>
					</ul>
				</li>
				<li>
					Metoda COCOMO(COnstructive COst MOdel) - metoda odhadu
					velikosti
					<ul>
						<li>Asi nejznámější přístup k odhadům</li>
						<li>Založeno na množství řádek zdrojového kódu</li>
					</ul>
				</li>
				<li>
					Functional Points - založeno na odhadu složitosti interakce
					s okolím
					<ul>
						<li>
							Lze ji uplatnit na konci detailního návrhu, kdy jsou
							již specifikovány transakce v budovaném systému a je
							jasná datová struktura
						</li>
						<li>
							Primárně sloužila metoda právě k měření složitosti
							systému. Vychází se z úměry, že čím je systém
							složitější, tím je také pracnější. Z toho se
							odvozuje i jeho pracnost. Metoda je poměrně
							objektivní
						</li>
					</ul>
				</li>
				<li>
					Use Case Points - založeno na využití Use Case modelů a
					scénářů
					<ul>
						<li>Výhodné pro první fáze vývoje</li>
						<li>
							Základní myšlenka vychází z toho, že funkcionalita
							softwaru je hlavním parametrem pro odhad pracnosti
						</li>
						<li>
							UCP se často kombinují – nebo převádějí na FP, řádky
							zdrojového kódu
						</li>
					</ul>
				</li>
			</ul>
		</main>

		<script src="../smooth-scroll.min.js"></script>
		<script>
			var scroll = new SmoothScroll('a[href*="#"]');
		</script>
	</body>
</html>
